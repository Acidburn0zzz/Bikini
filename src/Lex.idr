module Lex

import public Core
import public Syntax
import XSyntax
import Complete

%access public export

||| calculate open/close brackets
copenclose : String
           → (ℕ, ℕ, ℕ, String)
copenclose line =
    if isSuffixOf ['{'] lchars
        then (0, sizeReal, 2, line)
        else if isSuffixOf ['}'] lchars
                then (0, sizeReal, 1, line)
                else (0, sizeReal, 0, line)
 where lchars : List Char
       lchars = unpack line
       sizeReal : ℕ
       sizeReal = length $ takeWhile (== ' ') lchars

||| replicate missing closing brackets (for endComplete)
replicateX : (ℕ) → (ℕ) → (ℕ) → (ℤ)
           → String → String → String
replicateX x st s r a b =
    if (natToInt x) > r
        then (a ⧺ "\n" ⧺ b)
        else let rpl = pack $ with List replicate (st + (s × x)) ' '
             in replicateX (x + 1) st s r a (rpl ⧺ "}\n" ⧺ b)

||| fold-process open / close brackets
||| (last parsing/generation step)
endComplete : (ℕ, ℕ, ℕ, String)
            → (ℕ, ℕ, ℕ, String)
            → (ℕ, ℕ, ℕ, String)
endComplete (sc, oa, ca, a)
            (sb, ob, cb, b) = do
    if ca > 1 {- There is weird Int <-> Nat behaviour I need to resolve -}
        then let stex : ℕ = if ca ≡ 3 then let obi : ℤ = natToInt ob
                                               oai : ℤ = natToInt oa
                                               res : ℤ = obi - oai
                                           in intToNat res
                                      else 0
                 step : ℕ = if stex ≡ 0 then sc
                                        else stex
                 s : String = "\n"
             in if cb ≡ 1
                    then let oai : ℤ    = natToInt oa
                             obi : ℤ    = natToInt ob
                             stepi : ℤ  = natToInt step
                             diff : ℤ   = ((oai - obi) `div` stepi) - 1
                             strx = replicateX 1 ob step diff a b
                         in (step, ob, 2, strx) -- and now we check for it until the end
                    else if cb ≡ 2 then (step, ob, ca + 1, (a ⧺ s ⧺ b))
                                   else (step, ob, ca, (a ⧺ s ⧺ b))
        else (4, ob, cb, (a ⧺ "\n" ⧺ b))

||| build brackets by folding lines / steps
bracketBuilder : String → String
bracketBuilder noBra =
  let fnlns   = filter (\s => trim s /= "") (splitLines noBra)
      cStrs   = fnlns ⧺ [""] -- new line in the end
      cauto   = foldr1 foldProcessLines cStrs
      (_, cA) = foldl1 foldProcessRules $ (λ l → ([0, 0], l))
                                       ∰ (splitLines cauto)
      -- Generate map for indentation calculation
      mapopen = map copenclose (splitLines cA)
      -- I only need result string from mpped folding
      (_, _, _, brC) = foldl1 endComplete mapopen
  in "/* Generated by " ⧺ showVersion ⧺ " */\n" ⧺ brC

finalize : (List BValue) → Bool → String
finalize v bra =
  if bra then bracketBuilder noBra
         else noBra
 where noBra : String
       noBra = concat $ show ∰ v
